<html lang="en">

<head>
    <title>Final Project Level 1</title>
    <style>
        body {
            background-image: url('background1.jpg');
            background-repeat: repeat;
            background-size: 80%;
            margin: 0;
            overflow: hidden;
        }

        h1 {
            text-align: center;
        }

        img {
            position: absolute;
        }
    </style>
</head>

<body>
    <h1>Final Project Level 1</h1>

    <img id="myImg01" style="width: 100px; height: 80px; top: 400px; left: 50px;" src="dog1.jpg">
    <img id="myImg02" style="width: 100px; height: 80px; top: 400px; left: 250px;" src="dog2.jpg">

    <script>
        const myImg01 = document.getElementById('myImg01');
        const myImg02 = document.getElementById('myImg02');

        // Initial positions and velocities
        const velocity01 = { x: 0, y: 0 };
        const velocity02 = { x: 0, y: 0 };
        let isJumping01 = false;
        let isJumping02 = false;

        const keys = {
            w: { pressed: false },
            a: { pressed: false },
            s: { pressed: false },
            d: { pressed: false },
            ArrowUp: { pressed: false },
            ArrowLeft: { pressed: false },
            ArrowDown: { pressed: false },
            ArrowRight: { pressed: false },
        };

        const defaultGravity = 0.8;
        const lessGravity = 0.5;
        const moreGravity = 1.5;

        const speed = 7;

        // Track jump states and cooldown timers
        let jumpCount01 = 0; // Counts the number of jumps for myImg01
        let jumpCooldown01 = false; // Cooldown state for myImg01
        let jumpCount02 = 0; // Counts the number of jumps for myImg02
        let jumpCooldown02 = false; // Cooldown state for myImg02


        // Function to handle jumping logic
        function handleJump(player, velocity, jumpCount, cooldownFlag) {
            if (jumpCount < 2 && !cooldownFlag) { // Allow up to 2 jumps if not in cooldown
                velocity.y = -15; // Jump velocity
                jumpCount++;
            }
            return jumpCount;
        }

        // Function to reset jump states on landing
        function resetJump(player, jumpCount, cooldownFlag) {
            if (!cooldownFlag && jumpCount > 1) { // If double jump was used, apply cooldown
                cooldownFlag = true;
                setTimeout(() => {
                    cooldownFlag = false; // Reset cooldown after 0.5 seconds
                }, 500);
            }
            return [0, cooldownFlag]; // Reset jump count
        }

        function checkCollision(el1, el2) {
            const rect1 = el1.getBoundingClientRect();
            const rect2 = el2.getBoundingClientRect();

            return (
                rect1.left < rect2.left + rect2.width &&
                rect1.left + rect1.width > rect2.left &&
                rect1.top < rect2.top + rect2.height &&
                rect1.top + rect1.height > rect2.top
            );
        }

        function checkCollisionDirection(el1, el2) {
            const rect1 = el1.getBoundingClientRect();
            const rect2 = el2.getBoundingClientRect();

            const dx = (rect1.left + rect1.width / 2) - (rect2.left + rect2.width / 2);
            const dy = (rect1.top + rect1.height / 2) - (rect2.top + rect2.height / 2);

            const combinedHalfWidths = rect1.width / 2 + rect2.width / 2;
            const combinedHalfHeights = rect1.height / 2 + rect2.height / 2;

            if (Math.abs(dx) < combinedHalfWidths && Math.abs(dy) < combinedHalfHeights) {
                const overlapX = combinedHalfWidths - Math.abs(dx);
                const overlapY = combinedHalfHeights - Math.abs(dy);

                if (overlapX < overlapY) {
                    return dx > 0 ? "left" : "right"; // Collided from left or right
                } else {
                    return dy > 0 ? "top" : "bottom"; // Collided from top or bottom
                }
            }

            return null; // No collision
        }

        function updatePositions() {
            const rect01 = myImg01.getBoundingClientRect();
            const rect02 = myImg02.getBoundingClientRect();

            // Gravity for myImg01
            let gravity01 = defaultGravity;
            if (keys.w.pressed && !keys.s.pressed) gravity01 = lessGravity;
            else if (keys.s.pressed && !keys.w.pressed) gravity01 = moreGravity;

            // Gravity for myImg02
            let gravity02 = defaultGravity;
            if (keys.ArrowUp.pressed && !keys.ArrowDown.pressed) gravity02 = lessGravity;
            else if (keys.ArrowDown.pressed && !keys.ArrowUp.pressed) gravity02 = moreGravity;

            // Update positions with gravity
            velocity01.y += gravity01;
            velocity02.y += gravity02;

            // Update myImg01 position
            let newTop01 = rect01.top + velocity01.y;
            if (newTop01 >= window.innerHeight - rect01.height) {
                velocity01.y = 0;
                isJumping01 = false;
                [jumpCount01, jumpCooldown01] = resetJump(myImg01, jumpCount01, jumpCooldown01);
                newTop01 = window.innerHeight - rect01.height;
            }

            let newLeft01 = rect01.left + velocity01.x;

            // Update myImg02 position
            let newTop02 = rect02.top + velocity02.y;
            if (newTop02 >= window.innerHeight - rect02.height) {
                velocity02.y = 0;
                isJumping02 = false;
                [jumpCount02, jumpCooldown02] = resetJump(myImg02, jumpCount02, jumpCooldown02);
                newTop02 = window.innerHeight - rect02.height;
            }

            let newLeft02 = rect02.left + velocity02.x;

            // Apply positions
            myImg01.style.top = newTop01 + 'px';
            myImg01.style.left = newLeft01 + 'px';

            myImg02.style.top = newTop02 + 'px';
            myImg02.style.left = newLeft02 + 'px';

            // Collision detection
            const collisionDirection = checkCollisionDirection(myImg01, myImg02);
            if (collisionDirection) {
                console.log('Collision from:', collisionDirection);

                // Collision response based on direction
                if (collisionDirection === "top") {
                    velocity01.y = 0; // Stop y movement for myImg01
                    velocity02.y = 0; // Stop y movement for myImg02
                } else if (collisionDirection === "bottom") {
                    velocity01.y = 0; // Stop downward movement
                    velocity02.y = 0; // Stop downward movement
                } else if (collisionDirection === "left" || collisionDirection === "right") {
                    velocity01.x = 0; // Stop x movement for myImg01
                    velocity02.x = 0; // Stop x movement for myImg02
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Gradual deceleration for myImg01
            if (!keys.a.pressed && !keys.d.pressed) {
                velocity01.x = Math.abs(velocity01.x) < deceleration
                    ? 0
                    : velocity01.x - Math.sign(velocity01.x) * deceleration;
            }
            // Gradual deceleration for myImg02
            if (!keys.ArrowLeft.pressed && !keys.ArrowRight.pressed) {
                velocity02.x = Math.abs(velocity02.x) < deceleration
                    ? 0
                    : velocity02.x - Math.sign(velocity02.x) * deceleration;
            }

            // Movement for myImg01
            if (keys.a.pressed && !keys.d.pressed) {
                velocity01.x = Math.max(velocity01.x - acceleration, -maxSpeed);
                myImg01.style.transform = 'scaleX(1)'; // Flip when moving left
            } else if (keys.d.pressed && !keys.a.pressed) {
                velocity01.x = Math.min(velocity01.x + acceleration, maxSpeed);
                myImg01.style.transform = 'scaleX(-1)'; // Remove flip when moving right
            } else {
                velocity01.x = Math.abs(velocity01.x) < deceleration
                    ? 0
                    : velocity01.x - Math.sign(velocity01.x) * deceleration;
            }

            // Movement for myImg02
            if (keys.ArrowLeft.pressed && !keys.ArrowRight.pressed) {
                velocity02.x = Math.max(velocity02.x - acceleration, -maxSpeed);
                myImg02.style.transform = 'scaleX(1)'; // Flip when moving left
            } else if (keys.ArrowRight.pressed && !keys.ArrowLeft.pressed) {
                velocity02.x = Math.min(velocity02.x + acceleration, maxSpeed);
                myImg02.style.transform = 'scaleX(-1)'; // Remove flip when moving right
            } else {
                velocity02.x = Math.abs(velocity02.x) < deceleration
                    ? 0
                    : velocity02.x - Math.sign(velocity02.x) * deceleration;
            }

            updatePositions();
        }

        animate();

        window.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'w':
                    jumpCount01 = handleJump(myImg01, velocity01, jumpCount01, jumpCooldown01);
                    keys.w.pressed = true;
                    break;
                case 'a':
                    keys.a.pressed = true;
                    break;
                case 's':
                    keys.s.pressed = true;
                    break;
                case 'd':
                    keys.d.pressed = true;
                    break;
                case 'ArrowUp':
                    jumpCount02 = handleJump(myImg02, velocity02, jumpCount02, jumpCooldown02);
                    keys.ArrowUp.pressed = true;
                    break;
                case 'ArrowLeft':
                    keys.ArrowLeft.pressed = true;
                    break;
                case 'ArrowDown':
                    keys.ArrowDown.pressed = true;
                    break;
                case 'ArrowRight':
                    keys.ArrowRight.pressed = true;
                    break;
            }
        });

        window.addEventListener('keyup', (event) => {
            switch (event.key) {
                case 'a':
                    keys.a.pressed = false;
                    break;
                case 's':
                    keys.s.pressed = false;
                    break;
                case 'd':
                    keys.d.pressed = false;
                    break;
                case 'w':
                    keys.w.pressed = false;
                    break;
                case 'ArrowUp':
                    keys.ArrowUp.pressed = false;
                    break;
                case 'ArrowLeft':
                    keys.ArrowLeft.pressed = false;
                    break;
                case 'ArrowDown':
                    keys.ArrowDown.pressed = false;
                    break;
                case 'ArrowRight':
                    keys.ArrowRight.pressed = false;
                    break;
            }
        });
    </script>
</body>

</html>